// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: aclx.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Aclx_AclxHealthCheck_FullMethodName          = "/proto.Aclx/AclxHealthCheck"
	Aclx_RegistAppAcl_FullMethodName             = "/proto.Aclx/RegistAppAcl"
	Aclx_RegistAclApiRule_FullMethodName         = "/proto.Aclx/RegistAclApiRule"
	Aclx_RegistAclPermissionRule_FullMethodName  = "/proto.Aclx/RegistAclPermissionRule"
	Aclx_ReloadAppAcl_FullMethodName             = "/proto.Aclx/ReloadAppAcl"
	Aclx_AclxIsApiAllowed_FullMethodName         = "/proto.Aclx/AclxIsApiAllowed"
	Aclx_AclxCheckLoginPermission_FullMethodName = "/proto.Aclx/AclxCheckLoginPermission"
)

// AclxClient is the client API for Aclx service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AclxClient interface {
	AclxHealthCheck(ctx context.Context, in *AclxHealthCheckRequest, opts ...grpc.CallOption) (*AclxHealthCheckResponse, error)
	// 注册acl参数
	RegistAppAcl(ctx context.Context, in *RegistAppAclRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RegistAclApiRule(ctx context.Context, in *RegistAclApiRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RegistAclPermissionRule(ctx context.Context, in *RegistAclPermissionRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// reload app acl
	ReloadAppAcl(ctx context.Context, in *ReloadAppAclRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AclxIsApiAllowed(ctx context.Context, in *AclxIsApiAllowedRequest, opts ...grpc.CallOption) (*AclxIsApiAllowedResponse, error)
	// 检测是否有登录的权限
	AclxCheckLoginPermission(ctx context.Context, in *AclxCheckLoginPermissionRequest, opts ...grpc.CallOption) (*AclxCheckLoginPermissionResponse, error)
}

type aclxClient struct {
	cc grpc.ClientConnInterface
}

func NewAclxClient(cc grpc.ClientConnInterface) AclxClient {
	return &aclxClient{cc}
}

func (c *aclxClient) AclxHealthCheck(ctx context.Context, in *AclxHealthCheckRequest, opts ...grpc.CallOption) (*AclxHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AclxHealthCheckResponse)
	err := c.cc.Invoke(ctx, Aclx_AclxHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) RegistAppAcl(ctx context.Context, in *RegistAppAclRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Aclx_RegistAppAcl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) RegistAclApiRule(ctx context.Context, in *RegistAclApiRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Aclx_RegistAclApiRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) RegistAclPermissionRule(ctx context.Context, in *RegistAclPermissionRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Aclx_RegistAclPermissionRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) ReloadAppAcl(ctx context.Context, in *ReloadAppAclRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Aclx_ReloadAppAcl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) AclxIsApiAllowed(ctx context.Context, in *AclxIsApiAllowedRequest, opts ...grpc.CallOption) (*AclxIsApiAllowedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AclxIsApiAllowedResponse)
	err := c.cc.Invoke(ctx, Aclx_AclxIsApiAllowed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclxClient) AclxCheckLoginPermission(ctx context.Context, in *AclxCheckLoginPermissionRequest, opts ...grpc.CallOption) (*AclxCheckLoginPermissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AclxCheckLoginPermissionResponse)
	err := c.cc.Invoke(ctx, Aclx_AclxCheckLoginPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AclxServer is the server API for Aclx service.
// All implementations must embed UnimplementedAclxServer
// for forward compatibility.
type AclxServer interface {
	AclxHealthCheck(context.Context, *AclxHealthCheckRequest) (*AclxHealthCheckResponse, error)
	// 注册acl参数
	RegistAppAcl(context.Context, *RegistAppAclRequest) (*emptypb.Empty, error)
	RegistAclApiRule(context.Context, *RegistAclApiRuleRequest) (*emptypb.Empty, error)
	RegistAclPermissionRule(context.Context, *RegistAclPermissionRuleRequest) (*emptypb.Empty, error)
	// reload app acl
	ReloadAppAcl(context.Context, *ReloadAppAclRequest) (*emptypb.Empty, error)
	AclxIsApiAllowed(context.Context, *AclxIsApiAllowedRequest) (*AclxIsApiAllowedResponse, error)
	// 检测是否有登录的权限
	AclxCheckLoginPermission(context.Context, *AclxCheckLoginPermissionRequest) (*AclxCheckLoginPermissionResponse, error)
	mustEmbedUnimplementedAclxServer()
}

// UnimplementedAclxServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAclxServer struct{}

func (UnimplementedAclxServer) AclxHealthCheck(context.Context, *AclxHealthCheckRequest) (*AclxHealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclxHealthCheck not implemented")
}
func (UnimplementedAclxServer) RegistAppAcl(context.Context, *RegistAppAclRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistAppAcl not implemented")
}
func (UnimplementedAclxServer) RegistAclApiRule(context.Context, *RegistAclApiRuleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistAclApiRule not implemented")
}
func (UnimplementedAclxServer) RegistAclPermissionRule(context.Context, *RegistAclPermissionRuleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistAclPermissionRule not implemented")
}
func (UnimplementedAclxServer) ReloadAppAcl(context.Context, *ReloadAppAclRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadAppAcl not implemented")
}
func (UnimplementedAclxServer) AclxIsApiAllowed(context.Context, *AclxIsApiAllowedRequest) (*AclxIsApiAllowedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclxIsApiAllowed not implemented")
}
func (UnimplementedAclxServer) AclxCheckLoginPermission(context.Context, *AclxCheckLoginPermissionRequest) (*AclxCheckLoginPermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclxCheckLoginPermission not implemented")
}
func (UnimplementedAclxServer) mustEmbedUnimplementedAclxServer() {}
func (UnimplementedAclxServer) testEmbeddedByValue()              {}

// UnsafeAclxServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AclxServer will
// result in compilation errors.
type UnsafeAclxServer interface {
	mustEmbedUnimplementedAclxServer()
}

func RegisterAclxServer(s grpc.ServiceRegistrar, srv AclxServer) {
	// If the following call pancis, it indicates UnimplementedAclxServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Aclx_ServiceDesc, srv)
}

func _Aclx_AclxHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclxHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).AclxHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_AclxHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).AclxHealthCheck(ctx, req.(*AclxHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_RegistAppAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegistAppAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).RegistAppAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_RegistAppAcl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).RegistAppAcl(ctx, req.(*RegistAppAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_RegistAclApiRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegistAclApiRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).RegistAclApiRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_RegistAclApiRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).RegistAclApiRule(ctx, req.(*RegistAclApiRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_RegistAclPermissionRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegistAclPermissionRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).RegistAclPermissionRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_RegistAclPermissionRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).RegistAclPermissionRule(ctx, req.(*RegistAclPermissionRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_ReloadAppAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadAppAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).ReloadAppAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_ReloadAppAcl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).ReloadAppAcl(ctx, req.(*ReloadAppAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_AclxIsApiAllowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclxIsApiAllowedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).AclxIsApiAllowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_AclxIsApiAllowed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).AclxIsApiAllowed(ctx, req.(*AclxIsApiAllowedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aclx_AclxCheckLoginPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclxCheckLoginPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclxServer).AclxCheckLoginPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Aclx_AclxCheckLoginPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclxServer).AclxCheckLoginPermission(ctx, req.(*AclxCheckLoginPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Aclx_ServiceDesc is the grpc.ServiceDesc for Aclx service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Aclx_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Aclx",
	HandlerType: (*AclxServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AclxHealthCheck",
			Handler:    _Aclx_AclxHealthCheck_Handler,
		},
		{
			MethodName: "RegistAppAcl",
			Handler:    _Aclx_RegistAppAcl_Handler,
		},
		{
			MethodName: "RegistAclApiRule",
			Handler:    _Aclx_RegistAclApiRule_Handler,
		},
		{
			MethodName: "RegistAclPermissionRule",
			Handler:    _Aclx_RegistAclPermissionRule_Handler,
		},
		{
			MethodName: "ReloadAppAcl",
			Handler:    _Aclx_ReloadAppAcl_Handler,
		},
		{
			MethodName: "AclxIsApiAllowed",
			Handler:    _Aclx_AclxIsApiAllowed_Handler,
		},
		{
			MethodName: "AclxCheckLoginPermission",
			Handler:    _Aclx_AclxCheckLoginPermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aclx.proto",
}

const (
	RoleService_EnsureRoleExist_FullMethodName = "/proto.RoleService/EnsureRoleExist"
)

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	EnsureRoleExist(ctx context.Context, in *EnsureRoleExistRequest, opts ...grpc.CallOption) (*EnsureRoleExistResponse, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) EnsureRoleExist(ctx context.Context, in *EnsureRoleExistRequest, opts ...grpc.CallOption) (*EnsureRoleExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureRoleExistResponse)
	err := c.cc.Invoke(ctx, RoleService_EnsureRoleExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility.
type RoleServiceServer interface {
	EnsureRoleExist(context.Context, *EnsureRoleExistRequest) (*EnsureRoleExistResponse, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServiceServer struct{}

func (UnimplementedRoleServiceServer) EnsureRoleExist(context.Context, *EnsureRoleExistRequest) (*EnsureRoleExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureRoleExist not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}
func (UnimplementedRoleServiceServer) testEmbeddedByValue()                     {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_EnsureRoleExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureRoleExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).EnsureRoleExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_EnsureRoleExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).EnsureRoleExist(ctx, req.(*EnsureRoleExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnsureRoleExist",
			Handler:    _RoleService_EnsureRoleExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aclx.proto",
}

const (
	UserService_UserLogin_FullMethodName                 = "/proto.UserService/UserLogin"
	UserService_CreateUser_FullMethodName                = "/proto.UserService/CreateUser"
	UserService_UserRefreshToken_FullMethodName          = "/proto.UserService/UserRefreshToken"
	UserService_FindUserByUserId_FullMethodName          = "/proto.UserService/FindUserByUserId"
	UserService_FindUserIdList_FullMethodName            = "/proto.UserService/FindUserIdList"
	UserService_FindUserListByPhone_FullMethodName       = "/proto.UserService/FindUserListByPhone"
	UserService_ChangeToPrivateAccount_FullMethodName    = "/proto.UserService/ChangeToPrivateAccount"
	UserService_ChangeUserCurrentTenantId_FullMethodName = "/proto.UserService/ChangeUserCurrentTenantId"
	UserService_AddUserToRole_FullMethodName             = "/proto.UserService/AddUserToRole"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	UserLogin(ctx context.Context, in *UserServiceLoginRequest, opts ...grpc.CallOption) (*UserServiceLoginResponse, error)
	// 创建一个用户
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	UserRefreshToken(ctx context.Context, in *UserServiceRefreshTokenRequest, opts ...grpc.CallOption) (*UserServiceRefreshTokenResponse, error)
	FindUserByUserId(ctx context.Context, in *FindUserByUserIdRequest, opts ...grpc.CallOption) (*FindUserByUserIdResponse, error)
	// 搜索用户id列表
	FindUserIdList(ctx context.Context, in *FindUserIdListRequest, opts ...grpc.CallOption) (*FindUserIdListResponse, error)
	// 根据手机号查找
	FindUserListByPhone(ctx context.Context, in *FindUserListByPhoneRequest, opts ...grpc.CallOption) (*FindUserListByPhoneResponse, error)
	// 切换到个人帐号
	ChangeToPrivateAccount(ctx context.Context, in *ChangeToPrivateAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 切换到指定租户
	ChangeUserCurrentTenantId(ctx context.Context, in *ChangeUserCurrentTenantIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 确保用户在指定角色中
	AddUserToRole(ctx context.Context, in *AddUserToRoleRequest, opts ...grpc.CallOption) (*AddUserToRoleResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) UserLogin(ctx context.Context, in *UserServiceLoginRequest, opts ...grpc.CallOption) (*UserServiceLoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserServiceLoginResponse)
	err := c.cc.Invoke(ctx, UserService_UserLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserRefreshToken(ctx context.Context, in *UserServiceRefreshTokenRequest, opts ...grpc.CallOption) (*UserServiceRefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserServiceRefreshTokenResponse)
	err := c.cc.Invoke(ctx, UserService_UserRefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) FindUserByUserId(ctx context.Context, in *FindUserByUserIdRequest, opts ...grpc.CallOption) (*FindUserByUserIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindUserByUserIdResponse)
	err := c.cc.Invoke(ctx, UserService_FindUserByUserId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) FindUserIdList(ctx context.Context, in *FindUserIdListRequest, opts ...grpc.CallOption) (*FindUserIdListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindUserIdListResponse)
	err := c.cc.Invoke(ctx, UserService_FindUserIdList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) FindUserListByPhone(ctx context.Context, in *FindUserListByPhoneRequest, opts ...grpc.CallOption) (*FindUserListByPhoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindUserListByPhoneResponse)
	err := c.cc.Invoke(ctx, UserService_FindUserListByPhone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ChangeToPrivateAccount(ctx context.Context, in *ChangeToPrivateAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserService_ChangeToPrivateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ChangeUserCurrentTenantId(ctx context.Context, in *ChangeUserCurrentTenantIdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserService_ChangeUserCurrentTenantId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) AddUserToRole(ctx context.Context, in *AddUserToRoleRequest, opts ...grpc.CallOption) (*AddUserToRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserToRoleResponse)
	err := c.cc.Invoke(ctx, UserService_AddUserToRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	UserLogin(context.Context, *UserServiceLoginRequest) (*UserServiceLoginResponse, error)
	// 创建一个用户
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	UserRefreshToken(context.Context, *UserServiceRefreshTokenRequest) (*UserServiceRefreshTokenResponse, error)
	FindUserByUserId(context.Context, *FindUserByUserIdRequest) (*FindUserByUserIdResponse, error)
	// 搜索用户id列表
	FindUserIdList(context.Context, *FindUserIdListRequest) (*FindUserIdListResponse, error)
	// 根据手机号查找
	FindUserListByPhone(context.Context, *FindUserListByPhoneRequest) (*FindUserListByPhoneResponse, error)
	// 切换到个人帐号
	ChangeToPrivateAccount(context.Context, *ChangeToPrivateAccountRequest) (*emptypb.Empty, error)
	// 切换到指定租户
	ChangeUserCurrentTenantId(context.Context, *ChangeUserCurrentTenantIdRequest) (*emptypb.Empty, error)
	// 确保用户在指定角色中
	AddUserToRole(context.Context, *AddUserToRoleRequest) (*AddUserToRoleResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) UserLogin(context.Context, *UserServiceLoginRequest) (*UserServiceLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) UserRefreshToken(context.Context, *UserServiceRefreshTokenRequest) (*UserServiceRefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRefreshToken not implemented")
}
func (UnimplementedUserServiceServer) FindUserByUserId(context.Context, *FindUserByUserIdRequest) (*FindUserByUserIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindUserByUserId not implemented")
}
func (UnimplementedUserServiceServer) FindUserIdList(context.Context, *FindUserIdListRequest) (*FindUserIdListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindUserIdList not implemented")
}
func (UnimplementedUserServiceServer) FindUserListByPhone(context.Context, *FindUserListByPhoneRequest) (*FindUserListByPhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindUserListByPhone not implemented")
}
func (UnimplementedUserServiceServer) ChangeToPrivateAccount(context.Context, *ChangeToPrivateAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeToPrivateAccount not implemented")
}
func (UnimplementedUserServiceServer) ChangeUserCurrentTenantId(context.Context, *ChangeUserCurrentTenantIdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeUserCurrentTenantId not implemented")
}
func (UnimplementedUserServiceServer) AddUserToRole(context.Context, *AddUserToRoleRequest) (*AddUserToRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToRole not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserServiceLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserLogin(ctx, req.(*UserServiceLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserRefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserServiceRefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserRefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserRefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserRefreshToken(ctx, req.(*UserServiceRefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_FindUserByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).FindUserByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_FindUserByUserId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).FindUserByUserId(ctx, req.(*FindUserByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_FindUserIdList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserIdListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).FindUserIdList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_FindUserIdList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).FindUserIdList(ctx, req.(*FindUserIdListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_FindUserListByPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserListByPhoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).FindUserListByPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_FindUserListByPhone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).FindUserListByPhone(ctx, req.(*FindUserListByPhoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ChangeToPrivateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeToPrivateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ChangeToPrivateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ChangeToPrivateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ChangeToPrivateAccount(ctx, req.(*ChangeToPrivateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ChangeUserCurrentTenantId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeUserCurrentTenantIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ChangeUserCurrentTenantId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ChangeUserCurrentTenantId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ChangeUserCurrentTenantId(ctx, req.(*ChangeUserCurrentTenantIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_AddUserToRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserToRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).AddUserToRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_AddUserToRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).AddUserToRole(ctx, req.(*AddUserToRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _UserService_UserLogin_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "UserRefreshToken",
			Handler:    _UserService_UserRefreshToken_Handler,
		},
		{
			MethodName: "FindUserByUserId",
			Handler:    _UserService_FindUserByUserId_Handler,
		},
		{
			MethodName: "FindUserIdList",
			Handler:    _UserService_FindUserIdList_Handler,
		},
		{
			MethodName: "FindUserListByPhone",
			Handler:    _UserService_FindUserListByPhone_Handler,
		},
		{
			MethodName: "ChangeToPrivateAccount",
			Handler:    _UserService_ChangeToPrivateAccount_Handler,
		},
		{
			MethodName: "ChangeUserCurrentTenantId",
			Handler:    _UserService_ChangeUserCurrentTenantId_Handler,
		},
		{
			MethodName: "AddUserToRole",
			Handler:    _UserService_AddUserToRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aclx.proto",
}

const (
	TenantService_FindOneTenantByTenantId_FullMethodName    = "/proto.TenantService/FindOneTenantByTenantId"
	TenantService_AddUserToTenantRole_FullMethodName        = "/proto.TenantService/AddUserToTenantRole"
	TenantService_RemoveTenantUserFromTenant_FullMethodName = "/proto.TenantService/RemoveTenantUserFromTenant"
	TenantService_AddUserToTenant_FullMethodName            = "/proto.TenantService/AddUserToTenant"
	TenantService_FindTenantIdListByUserId_FullMethodName   = "/proto.TenantService/FindTenantIdListByUserId"
	TenantService_CreateTenant_FullMethodName               = "/proto.TenantService/CreateTenant"
	TenantService_DeleteTenant_FullMethodName               = "/proto.TenantService/DeleteTenant"
)

// TenantServiceClient is the client API for TenantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantServiceClient interface {
	FindOneTenantByTenantId(ctx context.Context, in *FindOneTenantByTenantIdRequest, opts ...grpc.CallOption) (*FindOneTenantByTenantIdResponse, error)
	// 确保用户在指定租户角色中
	AddUserToTenantRole(ctx context.Context, in *AddUserToTenantRoleRequest, opts ...grpc.CallOption) (*AddUserToTenantRoleResponse, error)
	// 将用户从租户中移除
	RemoveTenantUserFromTenant(ctx context.Context, in *RemoveTenantUserFromTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 将用户id增加到租户中
	AddUserToTenant(ctx context.Context, in *AddUserToTenantRequest, opts ...grpc.CallOption) (*AddUserToTenantResponse, error)
	// 查询指定的用户id的所有tenantId列表
	FindTenantIdListByUserId(ctx context.Context, in *FindTenantIdListByUserIdRequest, opts ...grpc.CallOption) (*FindTenantIdListByUserIdResponse, error)
	// 创建租户
	CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error)
	// 删除租户
	DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type tenantServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantServiceClient(cc grpc.ClientConnInterface) TenantServiceClient {
	return &tenantServiceClient{cc}
}

func (c *tenantServiceClient) FindOneTenantByTenantId(ctx context.Context, in *FindOneTenantByTenantIdRequest, opts ...grpc.CallOption) (*FindOneTenantByTenantIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindOneTenantByTenantIdResponse)
	err := c.cc.Invoke(ctx, TenantService_FindOneTenantByTenantId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) AddUserToTenantRole(ctx context.Context, in *AddUserToTenantRoleRequest, opts ...grpc.CallOption) (*AddUserToTenantRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserToTenantRoleResponse)
	err := c.cc.Invoke(ctx, TenantService_AddUserToTenantRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) RemoveTenantUserFromTenant(ctx context.Context, in *RemoveTenantUserFromTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TenantService_RemoveTenantUserFromTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) AddUserToTenant(ctx context.Context, in *AddUserToTenantRequest, opts ...grpc.CallOption) (*AddUserToTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserToTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_AddUserToTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) FindTenantIdListByUserId(ctx context.Context, in *FindTenantIdListByUserIdRequest, opts ...grpc.CallOption) (*FindTenantIdListByUserIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindTenantIdListByUserIdResponse)
	err := c.cc.Invoke(ctx, TenantService_FindTenantIdListByUserId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) CreateTenant(ctx context.Context, in *CreateTenantRequest, opts ...grpc.CallOption) (*CreateTenantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTenantResponse)
	err := c.cc.Invoke(ctx, TenantService_CreateTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantServiceClient) DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TenantService_DeleteTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantServiceServer is the server API for TenantService service.
// All implementations must embed UnimplementedTenantServiceServer
// for forward compatibility.
type TenantServiceServer interface {
	FindOneTenantByTenantId(context.Context, *FindOneTenantByTenantIdRequest) (*FindOneTenantByTenantIdResponse, error)
	// 确保用户在指定租户角色中
	AddUserToTenantRole(context.Context, *AddUserToTenantRoleRequest) (*AddUserToTenantRoleResponse, error)
	// 将用户从租户中移除
	RemoveTenantUserFromTenant(context.Context, *RemoveTenantUserFromTenantRequest) (*emptypb.Empty, error)
	// 将用户id增加到租户中
	AddUserToTenant(context.Context, *AddUserToTenantRequest) (*AddUserToTenantResponse, error)
	// 查询指定的用户id的所有tenantId列表
	FindTenantIdListByUserId(context.Context, *FindTenantIdListByUserIdRequest) (*FindTenantIdListByUserIdResponse, error)
	// 创建租户
	CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error)
	// 删除租户
	DeleteTenant(context.Context, *DeleteTenantRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTenantServiceServer()
}

// UnimplementedTenantServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTenantServiceServer struct{}

func (UnimplementedTenantServiceServer) FindOneTenantByTenantId(context.Context, *FindOneTenantByTenantIdRequest) (*FindOneTenantByTenantIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindOneTenantByTenantId not implemented")
}
func (UnimplementedTenantServiceServer) AddUserToTenantRole(context.Context, *AddUserToTenantRoleRequest) (*AddUserToTenantRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToTenantRole not implemented")
}
func (UnimplementedTenantServiceServer) RemoveTenantUserFromTenant(context.Context, *RemoveTenantUserFromTenantRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTenantUserFromTenant not implemented")
}
func (UnimplementedTenantServiceServer) AddUserToTenant(context.Context, *AddUserToTenantRequest) (*AddUserToTenantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToTenant not implemented")
}
func (UnimplementedTenantServiceServer) FindTenantIdListByUserId(context.Context, *FindTenantIdListByUserIdRequest) (*FindTenantIdListByUserIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTenantIdListByUserId not implemented")
}
func (UnimplementedTenantServiceServer) CreateTenant(context.Context, *CreateTenantRequest) (*CreateTenantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTenant not implemented")
}
func (UnimplementedTenantServiceServer) DeleteTenant(context.Context, *DeleteTenantRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTenant not implemented")
}
func (UnimplementedTenantServiceServer) mustEmbedUnimplementedTenantServiceServer() {}
func (UnimplementedTenantServiceServer) testEmbeddedByValue()                       {}

// UnsafeTenantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServiceServer will
// result in compilation errors.
type UnsafeTenantServiceServer interface {
	mustEmbedUnimplementedTenantServiceServer()
}

func RegisterTenantServiceServer(s grpc.ServiceRegistrar, srv TenantServiceServer) {
	// If the following call pancis, it indicates UnimplementedTenantServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TenantService_ServiceDesc, srv)
}

func _TenantService_FindOneTenantByTenantId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindOneTenantByTenantIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).FindOneTenantByTenantId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_FindOneTenantByTenantId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).FindOneTenantByTenantId(ctx, req.(*FindOneTenantByTenantIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_AddUserToTenantRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserToTenantRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).AddUserToTenantRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_AddUserToTenantRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).AddUserToTenantRole(ctx, req.(*AddUserToTenantRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_RemoveTenantUserFromTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTenantUserFromTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).RemoveTenantUserFromTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_RemoveTenantUserFromTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).RemoveTenantUserFromTenant(ctx, req.(*RemoveTenantUserFromTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_AddUserToTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserToTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).AddUserToTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_AddUserToTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).AddUserToTenant(ctx, req.(*AddUserToTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_FindTenantIdListByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindTenantIdListByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).FindTenantIdListByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_FindTenantIdListByUserId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).FindTenantIdListByUserId(ctx, req.(*FindTenantIdListByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_CreateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).CreateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_CreateTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).CreateTenant(ctx, req.(*CreateTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantService_DeleteTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServiceServer).DeleteTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantService_DeleteTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServiceServer).DeleteTenant(ctx, req.(*DeleteTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantService_ServiceDesc is the grpc.ServiceDesc for TenantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.TenantService",
	HandlerType: (*TenantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindOneTenantByTenantId",
			Handler:    _TenantService_FindOneTenantByTenantId_Handler,
		},
		{
			MethodName: "AddUserToTenantRole",
			Handler:    _TenantService_AddUserToTenantRole_Handler,
		},
		{
			MethodName: "RemoveTenantUserFromTenant",
			Handler:    _TenantService_RemoveTenantUserFromTenant_Handler,
		},
		{
			MethodName: "AddUserToTenant",
			Handler:    _TenantService_AddUserToTenant_Handler,
		},
		{
			MethodName: "FindTenantIdListByUserId",
			Handler:    _TenantService_FindTenantIdListByUserId_Handler,
		},
		{
			MethodName: "CreateTenant",
			Handler:    _TenantService_CreateTenant_Handler,
		},
		{
			MethodName: "DeleteTenant",
			Handler:    _TenantService_DeleteTenant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aclx.proto",
}
